import os, cffi, zlib

ffi = cffi.FFI()
ffi.cdef(open(os.path.join(os.path.dirname(__file__), 'esp_image_types.h'), 'r').read(), packed=True)
ffi.cdef(open(os.path.join(os.path.dirname(__file__), 'esp_partition_types.h'), 'r').read())

ESP_OTA_IMG_NEW             = 0x0
ESP_OTA_IMG_PENDING_VERIFY  = 0x1
ESP_OTA_IMG_VALID           = 0x2
ESP_OTA_IMG_INVALID         = 0x3
ESP_OTA_IMG_ABORTED         = 0x4
ESP_OTA_IMG_UNDEFINED       = 0xFFFFFFFF

PART_TYPE_APP               = 0x00
PART_SUBTYPE_FACTORY        = 0x00
PART_SUBTYPE_OTA_FLAG       = 0x10
PART_SUBTYPE_OTA_MASK       = 0x0f
PART_SUBTYPE_TEST           = 0x20
PART_TYPE_DATA              = 0x01
PART_SUBTYPE_DATA_OTA       = 0x00
PART_SUBTYPE_DATA_RF        = 0x01
PART_SUBTYPE_DATA_WIFI      = 0x02
PART_SUBTYPE_DATA_NVS_KEYS  = 0x04
PART_SUBTYPE_DATA_EFUSE_EM  = 0x05
PART_TYPE_END               = 0xff
PART_SUBTYPE_END            = 0xff

IMAGE_HEADER_DEFAULTS = {
    'magic': 0xe9,
    'segment_count': 2,
    'spi_mode': 2,
    'spi_speed': 0,
    'spi_size': 1,
    'wp_pin': 0xee,
    'spi_pin_drv': [0, 0, 0],
    'chip_id': 0,
    'min_chip_rev': 0,
    'min_chip_rev_full': 0,
    'max_chip_rev_full': 0x18f,
    'reserved': [0, 0, 0, 0],
    'hash_appended': 0
}

def gen_image_header(entry_addr, overrides={}):
    image_header = ffi.new('esp_image_header_t*')
    for k, v in IMAGE_HEADER_DEFAULTS.items():
        image_header.__setattr__(k, v)
    for k, v in overrides.items():
        image_header.__setattr__(k, v)
    image_header.entry_addr = entry_addr
    return bytes(ffi.buffer(image_header))

def gen_segment(load_addr, data):
    assert len(data) % 4 == 0, 'Segment data length must be a multiple of 4'
    segment_header = ffi.new('esp_image_segment_header_t*')
    segment_header.load_addr = load_addr
    segment_header.data_len = len(data)
    checksum = 0
    for v in data:
        checksum ^= v
    return bytes(ffi.buffer(segment_header)) + data, checksum

def postprocess_image(img_data, segment_checksums):
    # pad to 16 bytes aligned (excluding checksum byte)
    padding = b'\x00' * (15 - len(img_data) % 16)

    # calculate checksum (xor of 4 byte words)
    checksum = 0xEF
    for sc in segment_checksums:
        checksum ^= sc

    return img_data + padding + bytes([checksum])

def gen_image(entry_addr, segments, overrides={}):
    img_header = gen_image_header(entry_addr, overrides)
    all_segment_bytes = b''
    all_segment_checksums = []
    for segment in segments:
        seg_bytes, seg_checksum = gen_segment(*segment)
        all_segment_bytes += seg_bytes
        all_segment_checksums.append(seg_checksum)
    image_data = postprocess_image(img_header + all_segment_bytes, all_segment_checksums)
    return image_data

def gen_app_desc(secure_version, version_str, project_name, time, date, idf_ver, app_elf_sha256=None):
    app_desc = ffi.new('esp_app_desc_t*')
    app_desc.magic_word = 0xABCD5432
    app_desc.secure_version = secure_version
    app_desc.version = version_str
    app_desc.project_name = project_name
    app_desc.time = time
    app_desc.date = date
    app_desc.idf_ver = idf_ver
    if app_elf_sha256:
        app_desc.app_elf_sha256 = app_elf_sha256
    return bytes(ffi.buffer(app_desc))

def gen_ota_select_entry(ota_seq, seq_label, ota_state):
    ota_select_entry = ffi.new('esp_ota_select_entry_t*')
    ota_select_entry.ota_seq = ota_seq
    ota_select_entry.seq_label = seq_label
    ota_select_entry.ota_state = ota_state
    ota_select_entry.crc = zlib.crc32((ota_seq ^ 0xffffffff).to_bytes(4, 'little'))
    return bytes(ffi.buffer(ota_select_entry))

def gen_partition_part(part_type, subtype, pos_offset, pos_size, label, flags=0):
    pos = ffi.new('esp_partition_pos_t*')
    pos.offset = pos_offset
    pos.size = pos_size

    part_info = ffi.new('esp_partition_info_t*')
    part_info.magic = 0x50aa
    part_info.type = part_type
    part_info.subtype = subtype
    part_info.pos = pos[0]
    part_info.label = label
    part_info.flags = flags

    return bytes(ffi.buffer(part_info))

def gen_partition_table(parts):
    table = b''
    for part in parts:
        table += gen_partition_part(*part)
    return table + b'\xff' * (0xc00 - len(table))
